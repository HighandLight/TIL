## Array
  

- 같은 데이터 타입의 변수들로 이루어진 자료구조로, 배열을 구성하는 각각의 값인 `요소` (혹은 `원소(elements)`)와 배열의 Offset인 색인(index)로 구성되어 있음.
    
    → 배열의 각 요소들은 연속된 메모리에 저장되기에, 색인(index)를 이용하여 메모리의 주소를 계산할 수  있고, 색인(index)을 사용해 요소(element)에 바로 접근할 수 있다. 
    
- 대부분의 언어처럼, java 역시 n개의 원소를 가진 배열에 대해 0(맨 처음 요소)부터 n-1(맨 마지막 요소)의 index를 사용한다. (Python은 특별히 마지막 요소를 나타내는 -1 index를 사용할 수 있으나, java는 양의 정수만을 index값으로 갖는다.)
- 배열은 `참조 객체`이므로 배열을 가리키는 참조 변수는 스택 영역에 할당되며, 이 참조 변수가 가리키고 있는 주소값은 실제 힙 영역에 생성되는 배열의 주소값이다.

### 배열의 특징

- 배열은 크기가 고정적이다. 즉, 선언하는 순간 지정된 배열의 크기는 선언 이후에 변경할 수 없다.
- 배열의 선언 이후, 배열의 메모리 공간은 연속적으로 할당된다.
- 배열 선언 시 요소에 대한 값을 별도로 초기화해주지 않으면, 기본값이 할당된다.
- 배열의 물리주소와 논리주소는 동일하기에, 인덱스 연산자를 사용할 수 있다.

### 배열의 장점

- 특정 인덱스의 원소에 접근하려 할 때, 이에 대한 time-complexity는 O(1)이다.
- 특정 인덱스의 원소를 수정하려 할 떄, 이에 대한 time-complexity는 O(1)이다.

### 배열의 단점

1. 크기를 변경할 수 없다. 
    
    > 배열의 크기는 고정적이기에, 배열의 크기를 변경해야 할 경우, 새로운 배열을 생성 후 기존의 데이터를 복사해야 한다. 
    결국 새로운 배열로 데이터를 이동시키는 데에 O(n)만큼의 time-complexity가 소요되므로, 다뤄야 할 데이터의 개수가 가변적이라면 배열의 사용을 지양해야 한다.
    > 

1. 비순차적인 데이터의 추가, 삭제에 시간이 많이 걸린다. 
    
    > 배열 중간에 원소를 삽입해야 하는 경우, 삽입하고자 하는 인덱스 뒤에 있는 요소부터 맨 끝에 있는 요소까지의 모든 요소를 일일이 뒤로 한 칸씩 재할당해주어야 한다. 이때, 최악의 경우 time-complexity는 O(n)이 되므로, 매우 비효율적..
    
    배열 중간에 있는 원소를 삭제해야 하는 경우 역시 삭제하고자 하는 인덱스 뒤에 있는 요소부터 맨 끝에 있는 요소까지의 모든 요소를 일일이 앞으로 한칸씩 재할당해주어야 하기에, 최악의 경우 time-complexity는 O(n).
    > 

## ArrayList

- 크기가 고정적인 배열의 한계를 극복하기 위해 내부적으로 Array를 이용하여 요소를 저장하는 자료구조

### 배열리스트의 특징

- 배열 리스트 생성시, 별도의 크기를 지정해줄 필요 없이, 필요한 원소의 개수만큼 배열의 크기를 알아서 조정해줌 (조정 방식은 배열(Array)와 동일)
    - 이는 중간에 빈 공간을 허용하지 않는 리스트(List)의 특징을 구현체에서 구현한 것
- 물리 공간과 논리 공간이 동일하여 배열과 같이 인덱스 연산자를 사용할 수 있으나, 배열과 달리 인덱스 연산자를 직접 활용하지 않고 get() , set() 메서드 등을 활용함

### 배열리스트의 장점

- 인덱스 연산자를 활용하는 메서드들을 통해 특정 위치에 있는 원소에 대한 time-complexity가 O(1)임
- 저장 공간의 크기는 가변적이므로 사용자는 저장공간을 별도로 지정해주지 않아도 됨
- 빈 공간을 허용하지 않기에, 메모리가 효율적으로 운용됨

### 배열리스트의 단점

- 저장 공간의 크기가 가변적이라도, 공간을 늘리고 줄이는 과정은 배열과 동일하기에, 여전히 원소를 삽입, 삭제하는 time-complexity는 O(n)임

## Linked List

- 요소의 삽입, 삭제시 시간복잡도가 높다는 배열의 단점을 여전히 해결하지 못한 배열리스트를 보완하기 위해 나온 자료구조
- 각각의 데이터(요소)를 노드(Node)라는 객체로 표시
    - 데이터와 다음 노드를 가리키는 포인터(Pointer)로 이루어짐. 
    각각의 노드는 다음 노드의 주소를 가리키는 포인터를 가지고 있으며, 이를 통해 LInkedList는 연결된 구조를 표시.
- 단방향 연결리스트(Singly Linked List)와 양방향 연결리스트(Doubly Linked List) 그리고 원형 연결리스트(Circular Linked List)로 나뉨

### 연결리스트의 장점

- 데이터 추가/ 삭제에 대한 효율이 굉장히 뛰어남
    - 맨 앞에 데이터를 추가하는 경우, 가장 첫 노드와 다음 노드가 참조하고 있는 next노드의 링크만 바꿔주면 되기에, time-complexity는 O(1)
    

### 연결리스트의 단점

- 특정 위치의 데이터에 대한 접근의 time-complexity는 여전히 O(n)이다.
    - 연속된 메모리 공간으로 구성된 Array나 ArrayList와는 달리, Linked List(Singly)는 맨 처음 노드에서부터 계속 next노드를 타고 참조해야 하기에 비효율적임